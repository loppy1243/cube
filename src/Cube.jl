"""
Exploring the isometries of the cube.
"""
module Cube
using Plots; gr()
using Combinatorics: permutations

"""
Number of isometries of the cube. We may choose from 8 vertices, then 3
connecting vertices followed by two connecting vertices.
"""
const NUM_ISOMETRIES = 8*3*2
const NVERTICES = 8

"""
Matrix of R³ vertex vectors.

`R3_VERT_MAT[:, i]` corresponds to vertex `i`.
"""
const R3_VERT_MAT =
    [1  1 -1 -1 -1 -1  1  1;
     1 -1 -1  1  1 -1 -1  1;
     1  1  1  1 -1 -1 -1 -1]

"""
Generators as permutations vectors.
"""
const GENERATORS = (R=[2,3,4,1,8,5,6,7], r=[2,1,4,3,6,5,8,7], s=[3,6,5,4,1,8,7,2])

const ISOMETRIES = (R3rep((i1, i2, i3), σ)
                    for i1=(-1,1), i2=(-1,1), i3=(-1,1),
                        σ in permutations([1,2,3]))

"""
    permmat(σ)

Return the permutation matrix corresponding to the permutation vector `σ`.
"""
function permmat(σ)
    n = length(σ)
    ret = falses(n, n)
    ret[CartesianIndex.(zip(1:n, σ))] .= true
    ret
end

"""
    permvec(p)

Return the permutation vector corresponding to the permutation matrix `p`.
"""
function permvec(p)
    ret = Vector{Int}(undef, size(p, 1))
    for i in eachindex(ret)
        ret[i] = sum(j*p[i, j] for j=1:size(p, 2))
    end

    ret
end

"""
    R3rep(I)

Generate the R³ isometry matrix from the corresponding adjacency representation
matrix `I`.
"""
R3rep(I) = 4\R3_VERT_MAT*J(I)

"""
    R3rep(ι, σ)

Generate the R³ isommetry matrix from a choice of sign `ι` and permutation
vector `σ`.


`ι` must be an indexable collection of length 3 consisting of `+1` or `-1`.
"""
R3rep(ι, σ) = (p=permmat(σ); hcat(ι[1]*p[:, 1], ι[2]*p[:, 2], ι[3]*p[:, 3]))
J(I) = hcat(sum(I[:, k] for k in (1, 2, 7, 8)),
            sum(I[:, k] for k in (1, 4, 5, 8)),
            sum(I[:, k] for k in (1, 2, 3, 4)))

"""
    adjrep(M)

Generate the adjacency premutation matrix corresponding to the R³ representation
matrix `M`.
"""
function adjrep(M)
    ret = BitMatrix(undef, 8, 8)
    vert_mat_perm = M*R3_VERT_MAT
    for I in CartesianIndices(ret)
        i, j = Tuple(I)
        ret[I] = R3_VERT_MAT[:, i] == vert_mat_perm[:, j]
    end

    ret
end


"""
    plotall(f, dir, itr)

Save PNG images to `dir` of plots generated by mapping `f` over `itr`.

Each plot will be call `i.png`, where `i` is its position in `itr`.
"""
function plotall(f, dir, itr)
    mkpath(dir)
    for (i, I) in enumerate(itr)
        savefig(f(I), "$dir/$i.png")
    end
end

"""
    tileplot(K, n, I)

Plot the adjacency representation tiling of `I` by `K` as a `(2n+1)x(2n+1)`
matrix with `I` in the center.
"""
function tileplot(K, n, I)
    bb = reverse(I, dims=1)
    rr = reverse(I, dims=2)
    br = reverse(bb, dims=2)

    K_T = transpose(K)
    mid_tile_line = I .+ 0.5
    tile_line = I
    left = I
    right = I
    for _ = 1:n
        left = left*K_T
        right = right*K
        mid_tile_line = hcat(left, mid_tile_line, right)
        tile_line = hcat(left, tile_line, right)
    end
    tileing = mid_tile_line
    top_line = tile_line
    bottom_line = tile_line
    for _ = 1:n
        top_line = K*top_line
        bottom_line = K_T*bottom_line
        tileing = vcat(top_line, tileing, bottom_line)
    end

    Plots.heatmap(reverse(tileing, dims=1), color=:dense, xaxis=false, yaxis=false,
                  legend=false)
end

gen_adjmats() = [adjrep(M) for M in ISOMETRIES]

## Naming scheme: K_tilings    --> tilings by K of all Isom(C).
##                tilings_of_I --> tilings by all Isom(C) of I.
function plot_reversal_tilings()
    adjmats = gen_adjmats()

    F = permmat(8:-1:1)
    plotall(I->tileplot(F, 7, I), "plots/reversals/", adjmats)
end

function plot_generator_tilings()
    adjmats = gen_adjmats()

    K = permmat(GENERATORS.r)
    plotall(I->tileplot(K, 7, I), "plots/r/", adjmats)

    K = permmat(GENERATORS.s)
    plotall(I->tileplot(K, 7, I), "plots/s/", adjmats)

    K = permmat(GENERATORS.R)
    plotall(I->tileplot(K, 7, I), "plots/R/", adjmats)
end

function plot_tilings_of_identity()
    adjmats = gen_adjmats()

    I = permmat(1:8)
    plotall(K->tileplot(K, 7, I), "plots/identity/", adjmats)
end

# Yeah, if these were real random numbers this might never terminate. But oh well.
function randperm(n)
    ret = Vector{Int}(undef, n)
    for i in eachindex(ret)
        ret[i] = rand(1:n)
        while ret[i] in ret[1:i-1]
            ret[i] = rand(1:n)
        end
    end

    ret
end

function plot_rand_tilings()
    adjmats = gen_adjmats()
  
    perm = randperm(8)
    str = prod(string.(perm))
    println("Permutation: ($str)")
    K = permmat(perm)
    plotall(I->tileplot(K, 7, I), "plots/$str/", adjmats)
end

end # Cube
